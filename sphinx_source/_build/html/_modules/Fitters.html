
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Fitters &#8212; PyXMRTool 0.9 documentation</title>
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PyXMRTool 0.9 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h3><a href="../index.html">Table Of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">PyXMRToolâ€™s documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro.html">todo: Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install.html">todo: Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">todo: Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api.html">API</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for Fitters</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="sd">&quot;&quot;&quot;Contains different optimization algorithms designed to fit reflectivity data.</span>
<span class="sd">   They take advantage of parallelization to be used on multiprocessor system.</span>
<span class="sd">   </span>
<span class="sd">   The algorithms are developed by Martin Zwiebel and I just adopted them with slight changes to PyXMRTool.</span>
<span class="sd">   More information can be found in the PhD thesis of Martin Zwiebler.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1">#Python Version 2.7</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Yannic Utz&quot;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
<span class="n">__credits__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Yannic Utz and Martin Zwiebler&quot;</span><span class="p">]</span>
<span class="n">__license__</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
<span class="n">__maintainer__</span> <span class="o">=</span> <span class="s2">&quot;Yannic Utz&quot;</span>
<span class="n">__email__</span> <span class="o">=</span> <span class="s2">&quot;yannic.utz@tu-dresden.de&quot;</span>
<span class="n">__status__</span> <span class="o">=</span> <span class="s2">&quot;beta&quot;</span>


<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span>
<span class="kn">import</span> <span class="nn">os.path</span>
<span class="kn">import</span> <span class="nn">joblib</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="c1">#settings############################</span>
<span class="n">numerical_derivative_factor</span><span class="o">=</span><span class="mf">1.0e-9</span>                          <span class="c1">#defines in principle the the magnitude of  &quot;Delta x&quot; for the aproximation of a derivative by &quot;Delta y/Delta x&quot;</span>
<span class="c1">#####################################</span>

<div class="viewcode-block" id="Evolution"><a class="viewcode-back" href="../modules-api/fitters.html#Fitters.Evolution">[docs]</a><span class="k">def</span> <span class="nf">Evolution</span><span class="p">(</span><span class="n">costfunction</span><span class="p">,</span> <span class="n">parameter_settings</span> <span class="p">,</span> <span class="n">iterations</span><span class="p">,</span> <span class="n">number_of_cores</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">generation_size</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">mutation_strength</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">elite</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">parent_percentage</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">control_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plotfunction</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evolutionary fit algorithm. Slow but good in finding the global minimum.</span>
<span class="sd">    Return the optimized parameter set and the coresponding value of the costfunction.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    costfunction : callable</span>
<span class="sd">        A function which returns a measure (cost) for the difference between measurement and simulated data according to the paramter set given as list of values. Usually the sum of squared residuals (SSR) is used as cost. It should usally be the method :meth:`SampleRepresentation.ReflDataSimulator.getSSR` of an instance of :class:`SampleRepresentation.ReflDataSimulator` wrapped in a function. The wrapping is necessaray due to some implemetation issues connected to the parallelization.</span>
<span class="sd">        Example for the wrapping::</span>
<span class="sd">            </span>
<span class="sd">            simu = SampleRepresentation.ReflDataSimulator(&quot;l&quot;)</span>
<span class="sd">            ...</span>
<span class="sd">            def cost(fitpararray):</span>
<span class="sd">                return simu.getSSR(fitpararray)</span>
<span class="sd">    </span>
<span class="sd">        Pass then the function *cost* as **costfunction**. It can also be any other function which takes the array of fit parameters and returns one real value which should be minimized by :meth:`.Evolution`.</span>
<span class="sd">        </span>
<span class="sd">    parameter_settings: tuple of lists of floats</span>
<span class="sd">        Sets start values, lower and upper limit of the parameters as *(startfitparameters, lower_limits, upper_limits )*, where each of the entries is an list/array of values of same length.</span>
<span class="sd">    iterations : int </span>
<span class="sd">        number of iterations/generations</span>
<span class="sd">    number_of_cores : int </span>
<span class="sd">        Number of jobs used in parallel. Best performance when set to the number of available cores on your computer.</span>
<span class="sd">    generation_size : int </span>
<span class="sd">        Generate this many individual fit parameter sets in each generation.</span>
<span class="sd">    mutation_strength : float</span>
<span class="sd">        Mutates children by adding this factor times (upper_limit - lower_limit)  --&gt; use rather small values </span>
<span class="sd">    elite : int</span>
<span class="sd">        Remember the best individuals for the next generation.</span>
<span class="sd">    parent_percentage : flota</span>
<span class="sd">        Use this fraction of a gereneration (the best) for reproduction.</span>
<span class="sd">    control_file : str </span>
<span class="sd">        Filename of a control file. If it is given, you can abort the optimization routine by writing &quot;terminate 1&quot; to the beginning of its first line.</span>
<span class="sd">    plotfunction : callable</span>
<span class="sd">        Function which is used to plot the current state of fitting (simulated data with currently best parameter set) after every iteration if given. It should take only one parameter: the array of fitparameters.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    This Evolutionary algorithm is mainly the same as Martins. Only the rule for mutation has changed:</span>
<span class="sd">    </span>
<span class="sd">    | Martin: ``children[i]=children[i] * (1 + s * random float(-1,1))``</span>
<span class="sd">    | I:      ``children[i]=children[i] + s * random float(-1,1)*(upper_limits-lower_limits)``</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#unpack parameter settings</span>
    <span class="p">(</span><span class="n">startfitparameters</span><span class="p">,</span> <span class="n">lower_limits</span><span class="p">,</span> <span class="n">upper_limits</span> <span class="p">)</span><span class="o">=</span><span class="n">parameter_settings</span>
    
    <span class="c1">#check parameters</span>
    <span class="c1">#if not callable(costfunction):</span>
    <span class="c1">#    raise TypeError(&quot;\&#39;costfunction\&#39; has to be callable.&quot;)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">startfitparameters</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">lower_limits</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">lower_limits</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">upper_limits</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">startfitparameters</span><span class="se">\&#39;</span><span class="s2"> and constraints don&#39;t match in length.&quot;</span><span class="p">)</span>
    <span class="n">pos_integer_pars</span><span class="o">=</span><span class="p">[</span><span class="n">number_of_cores</span><span class="p">,</span><span class="n">iterations</span><span class="p">,</span><span class="n">generation_size</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pos_integer_pars</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid parameter.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">p</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Parameter has to be positive.&quot;</span><span class="p">)</span>
    <span class="n">pos_real_pars</span><span class="o">=</span><span class="p">[</span><span class="n">mutation_strength</span><span class="p">,</span> <span class="n">elite</span><span class="p">,</span> <span class="n">parent_percentage</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pos_real_pars</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid parameter.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">p</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Parameter has to be positive.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">control_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">control_file</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">control_file</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; is not an existing path.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">plotfunction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">plotfunction</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">plotfunction</span><span class="se">\&#39;</span><span class="s2"> has to be callable.&quot;</span><span class="p">)</span>

    

      
    <span class="c1">#use numpy arrays</span>
    <span class="n">startfitparameters</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">startfitparameters</span><span class="p">)</span>
    <span class="n">lower_limits</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lower_limits</span><span class="p">)</span>
    <span class="n">upper_limits</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">upper_limits</span><span class="p">)</span>
    
    <span class="n">number_of_parents</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">generation_size</span><span class="o">*</span><span class="n">parent_percentage</span><span class="p">)</span>
    
   
    <span class="c1">#Initial state:</span>
    <span class="n">number_of_fitparameters</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">startfitparameters</span><span class="p">)</span>
    <span class="n">randomnumbers</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">generation_size</span><span class="p">,</span> <span class="n">number_of_fitparameters</span><span class="p">)</span>
    <span class="n">all_fitpararrays</span><span class="o">=</span><span class="n">lower_limits</span><span class="o">+</span><span class="n">randomnumbers</span><span class="o">*</span><span class="p">(</span><span class="n">upper_limits</span><span class="o">-</span><span class="n">lower_limits</span><span class="p">)</span>
    <span class="n">all_fitpararrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">startfitparameters</span>                                          <span class="c1">#use the given start values just as one of many guesses (replace one random guess)</span>
    <span class="n">children</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">generation_size</span><span class="p">,</span> <span class="n">number_of_fitparameters</span><span class="p">))</span>
    
    <span class="nb">print</span> <span class="s2">&quot;Start Evolution of &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">iterations</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; Generations with &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">startfitparameters</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot; Parameters.&quot;</span>
    <span class="n">ite</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>

        <span class="n">ite</span><span class="o">+=</span><span class="mi">1</span>

        <span class="c1">#Calculate the costfunction (usually chisquare) for each individuum</span>
        <span class="n">out</span><span class="o">=</span><span class="n">joblib</span><span class="o">.</span><span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">number_of_cores</span><span class="p">)(</span><span class="n">joblib</span><span class="o">.</span><span class="n">delayed</span><span class="p">(</span><span class="n">costfunction</span><span class="p">)(</span><span class="n">all_fitpararrays</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">generation_size</span><span class="p">)</span> <span class="p">)</span>  
        <span class="n">ranking_list</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>                                 <span class="c1">#stores the best results as indices of the elements of out</span>
        <span class="c1">#Write the current state</span>
        <span class="nb">print</span> <span class="s2">&quot;   Generation &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ite</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;: Cost=&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">ranking_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="c1">#plot the current state (best guess)</span>
        <span class="k">if</span> <span class="n">plotfunction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plotfunction</span><span class="p">(</span><span class="n">all_fitpararrays</span><span class="p">[</span><span class="n">ranking_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="c1">#check for termination</span>
        <span class="k">if</span> <span class="n">control_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">control_file</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">line</span><span class="o">=</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;terminate&quot;</span> <span class="ow">and</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">==</span><span class="mi">1</span><span class="p">):</span>
                        <span class="nb">print</span> <span class="s2">&quot;!! Iteration terminated, returning current status&quot;</span>
                        <span class="k">return</span> <span class="n">all_fitpararrays</span><span class="p">[</span><span class="n">ranking_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">out</span><span class="p">[</span><span class="n">ranking_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="c1">#return if number of iterations is reached</span>
        <span class="k">if</span><span class="p">(</span><span class="n">ite</span><span class="o">==</span><span class="n">iterations</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">all_fitpararrays</span><span class="p">[</span><span class="n">ranking_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">out</span><span class="p">[</span><span class="n">ranking_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>       <span class="c1">#return best fit parameters and corresponding value of the costfunction  </span>
        
        <span class="c1">#determin next generation</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">generation_size</span><span class="p">):</span>
            <span class="c1">#Copy the elite</span>
            <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">elite</span><span class="p">):</span>
                <span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">all_fitpararrays</span><span class="p">[</span><span class="n">ranking_list</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#Reproduce children from the mother and father randomly</span>
                <span class="n">Mother</span><span class="o">=</span><span class="n">i</span><span class="o">%</span><span class="n">number_of_parents</span><span class="p">;</span>
                <span class="n">Father</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">number_of_parents</span><span class="p">)</span>
                <span class="c1">#No Cloning</span>
                <span class="k">while</span><span class="p">(</span><span class="n">Father</span><span class="o">==</span><span class="n">Mother</span><span class="p">):</span>
                    <span class="n">Father</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">number_of_parents</span><span class="p">)</span>

                <span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">all_fitpararrays</span><span class="p">[</span><span class="n">ranking_list</span><span class="p">[</span><span class="n">Mother</span><span class="p">]]</span><span class="o">+</span><span class="n">all_fitpararrays</span><span class="p">[</span><span class="n">ranking_list</span><span class="p">[</span><span class="n">Father</span><span class="p">]])</span>

                <span class="c1">#Mutate the children</span>
                <span class="n">r</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">number_of_fitparameters</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
                <span class="n">r</span><span class="o">=</span><span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="n">upper_limits</span><span class="o">-</span><span class="n">lower_limits</span><span class="p">)</span>                                <span class="c1">#added by Yannic to make the mutation depending on the value range of a parameter</span>
                <span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">r</span><span class="o">*</span><span class="n">mutation_strength</span>                  <span class="c1">#changed mutation rule by Yannic (mutation not depending on parameter value)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_fitparameters</span><span class="p">):</span>    <span class="c1">#periodic boundaries (changed by Yannic; Martin sets to the limits if theey are exceeded)</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="n">lower_limits</span><span class="p">[</span><span class="n">j</span><span class="p">]):</span>
                        <span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">upper_limits</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="p">(</span><span class="n">lower_limits</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span><span class="o">%</span><span class="p">(</span><span class="n">upper_limits</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">lower_limits</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="k">elif</span><span class="p">(</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">&gt;</span><span class="n">upper_limits</span><span class="p">[</span><span class="n">j</span><span class="p">]):</span>
                        <span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">lower_limits</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">upper_limits</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">%</span><span class="p">(</span><span class="n">upper_limits</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">lower_limits</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="c1">#The children are now the new generation</span>
        <span class="n">all_fitpararrays</span><span class="o">=</span><span class="n">children</span></div>
        
        

        
        
<div class="viewcode-block" id="Levenberg_Marquardt_Fitter"><a class="viewcode-back" href="../modules-api/fitters.html#Fitters.Levenberg_Marquardt_Fitter">[docs]</a><span class="k">def</span> <span class="nf">Levenberg_Marquardt_Fitter</span><span class="p">(</span><span class="n">residualandcostfunction</span><span class="p">,</span>  <span class="n">parameter_settings</span> <span class="p">,</span> <span class="n">parallel_points</span> <span class="p">,</span><span class="n">number_of_cores</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">control_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plotfunction</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Modified Levenberg-Marquard algorithm (see PhD thesis of Martin Zwiebler). Good convergence, but might end up in a local mininum.</span>
<span class="sd">    Return the optimized parameter set and the coresponding value of the costfunction.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    residualandcostfunction : callable</span>
<span class="sd">        A function which returns the differences between simulated and measured data points (residuals) as list and a scalar measure (cost) for these differences in total according to the paramter set given as list of values. Usually the sum of squared residuals (SSR) is used as cost. It should usally be the method :meth:`SampleRepresentation.ReflDataSimulator.getResidualsSSR` of an instance of :class:`SampleRepresentation.ReflDataSimulator` wrapped in a function. The wrapping is necessaray due to some implemetation issues connected to the parallelization.</span>
<span class="sd">        Example for the wrapping::</span>
<span class="sd">            </span>
<span class="sd">            simu = SampleRepresentation.ReflDataSimulator(&quot;l&quot;)</span>
<span class="sd">            ...</span>
<span class="sd">            def rescost(fitpararray):</span>
<span class="sd">                return simu.getResidualsSSR(fitpararray)</span>
<span class="sd">    </span>
<span class="sd">        Pass then the function *rescost* as **costfunction**. It can also be any other function which takes the array of fit parameters and returns a tuple of </span>
<span class="sd">        1.) a list of residuals (will be used to determine derivatives) 2.) a value of the costfunction which should be minimized by :meth:`.Levenberg_Marquardt_Fitter`.</span>
<span class="sd">        </span>
<span class="sd">    parameter_settings: tuple of lists of floats</span>
<span class="sd">        Sets start values, lower and upper limit of the parameters as *(startfitparameters, lower_limits, upper_limits )*, where each of the entries is an list/array of values of same length.</span>
<span class="sd">    parallel_points : int </span>
<span class="sd">        This should be something like the number of threads that can run in parallel/number of cores. The algorithm will first find a direction for a good descent and then check this number of points on the line. The best one will yield the new fit parameter set.</span>
<span class="sd">    number_of_cores : int </span>
<span class="sd">        Number of jobs used in parallel. Best performance when set to the number of available cores on your computer.</span>
<span class="sd">    strict : bool</span>
<span class="sd">        Usually this algorithm fails if the residuals are locally independent of one of the parameters. If you set **stict** = *False* this parameter will be neglected locally.</span>
<span class="sd">    control_file : str </span>
<span class="sd">        Filename of a control file. If it is given, you can abort the optimization routine by writing &quot;terminate 1&quot; to the beginning of its first line.</span>
<span class="sd">    plotfunction : callable</span>
<span class="sd">        Function which is used to plot the current state of fitting (simulated data with currently best parameter set) after every iteration if given. It should take only one parameter: the array of fitparameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1">#unpack parameter settings</span>
    <span class="p">(</span><span class="n">startfitparameters</span><span class="p">,</span> <span class="n">lower_limits</span><span class="p">,</span> <span class="n">upper_limits</span> <span class="p">)</span><span class="o">=</span><span class="n">parameter_settings</span>
    
    <span class="c1">#check parameters</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">residualandcostfunction</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">residualandcostfunction</span><span class="se">\&#39;</span><span class="s2"> has to be callable.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">startfitparameters</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">lower_limits</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">lower_limits</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">upper_limits</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">startfitparameters</span><span class="se">\&#39;</span><span class="s2"> and constraints don&#39;t match in length.&quot;</span><span class="p">)</span>
    <span class="n">pos_integer_pars</span><span class="o">=</span><span class="p">[</span><span class="n">number_of_cores</span><span class="p">,</span><span class="n">parallel_points</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pos_integer_pars</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid parameter.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">p</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Parameter has to be positive.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strict</span><span class="p">,</span><span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">strict</span><span class="se">\&#39;</span><span class="s2"> has to be of type bool.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">control_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">control_file</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">control_file</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; is not an existing path.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">plotfunction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">plotfunction</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">plotfunction</span><span class="se">\&#39;</span><span class="s2"> has to be callable.&quot;</span><span class="p">)</span>

    

   
    <span class="c1">#use numpy arrays</span>
    <span class="n">startfitparameters</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">startfitparameters</span><span class="p">)</span>
    <span class="n">lower_limits</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lower_limits</span><span class="p">)</span>
    <span class="n">upper_limits</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">upper_limits</span><span class="p">)</span>
    
    <span class="n">number_of_fitparameters</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">startfitparameters</span><span class="p">)</span>
    
    <span class="n">aite</span><span class="o">=</span><span class="n">startfitparameters</span>

    <span class="s2">&quot;Start Levenberg-Marquardt algorithm with &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">startfitparameters</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot; Parameters.&quot;</span>
    <span class="n">ite</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">while</span><span class="p">(</span><span class="kc">True</span><span class="p">):</span>

        <span class="k">if</span><span class="p">(</span><span class="n">ite</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">):</span>
            <span class="c1">#Go here once you calculated the first step</span>

            <span class="c1">#Calculate the fit parameters on the line of descent</span>
            <span class="n">all_fitpararrays</span><span class="o">=</span><span class="p">[</span><span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">aite</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">parallel_points</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">parallel_points</span><span class="p">):</span>
                <span class="n">scale</span><span class="o">=</span><span class="mf">0.5</span><span class="o">**</span><span class="n">i</span>
                <span class="n">all_fitpararrays</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">all_fitpararrays</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">scale</span><span class="o">*</span><span class="n">DTr</span> <span class="o">-</span> <span class="n">scale</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">scale</span><span class="p">)</span><span class="o">*</span><span class="n">DTr2</span>


            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">parallel_points</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_fitparameters</span><span class="p">):</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">all_fitpararrays</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">lower_limits</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                        <span class="n">all_fitpararrays</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">lower_limits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">elif</span><span class="p">(</span><span class="n">all_fitpararrays</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="n">upper_limits</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                        <span class="n">all_fitpararrays</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">upper_limits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

          
            <span class="c1">##Calculate the residuals and cost (e.g. difference between simulated and measured reflectivities) on the line of descent, in parallel</span>
            <span class="n">out</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">joblib</span><span class="o">.</span><span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">number_of_cores</span><span class="p">)(</span><span class="n">joblib</span><span class="o">.</span><span class="n">delayed</span><span class="p">(</span><span class="n">residualandcostfunction</span><span class="p">)(</span> <span class="n">all_fitpararrays</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">parallel_points</span><span class="p">)</span> <span class="p">))</span>
            
            
            <span class="c1">#Find the lowest chisquare</span>
            <span class="n">min_i</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">out</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">aite</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">all_fitpararrays</span><span class="p">[</span><span class="n">min_i</span><span class="p">])</span>
            
            <span class="n">fiterror2</span><span class="o">=</span><span class="n">out</span><span class="p">[</span><span class="n">min_i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            
            <span class="k">if</span><span class="p">(</span> <span class="nb">abs</span><span class="p">(</span> <span class="p">(</span><span class="n">fiterror1</span><span class="o">-</span><span class="n">fiterror2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">fiterror1</span><span class="o">+</span><span class="n">fiterror2</span><span class="p">)</span> <span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1.0e-7</span> <span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;  --&gt; Converged at cost=&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">fiterror2</span><span class="p">)</span> <span class="p">)</span>
                <span class="k">return</span> <span class="n">aite</span><span class="p">,</span> <span class="n">out</span><span class="p">[</span><span class="n">min_i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>                      <span class="c1">#return best fit parameters and corresponding value of the costfunction      </span>
            <span class="k">elif</span> <span class="n">control_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">control_file</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                        <span class="n">line</span><span class="o">=</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
                        <span class="k">if</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;terminate&quot;</span> <span class="ow">and</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">==</span><span class="mi">1</span><span class="p">):</span>
                            <span class="nb">print</span> <span class="s2">&quot;!! Iteration terminated, current status&quot;</span>
                            <span class="k">return</span> <span class="n">aite</span><span class="p">,</span> <span class="n">out</span><span class="p">[</span><span class="n">min_i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            
            <span class="nb">print</span> <span class="s2">&quot;   Iteration &quot;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ite</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;: old cost = &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">fiterror1</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;, new cost = &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">fiterror2</span><span class="p">)</span>
            
            <span class="c1">#plot the current state of fitting</span>
            <span class="k">if</span> <span class="n">plotfunction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">plotfunction</span><span class="p">(</span><span class="n">aite</span><span class="p">)</span>
            

            
       
        
           
        
        <span class="c1">#Make Fit parameters for the calculation of the derivative</span>
        <span class="n">all_fitpararrays</span><span class="o">=</span><span class="p">[</span><span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">aite</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_fitparameters</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>          <span class="c1">##this Matrix stores fitparameters for each point that is calculated in parallel</span>
        <span class="n">delta</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">number_of_fitparameters</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_fitparameters</span><span class="p">):</span>
            <span class="k">if</span><span class="p">(</span><span class="n">all_fitpararrays</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">lower_limits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&lt;</span><span class="n">upper_limits</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">):</span>
                <span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">numerical_derivative_factor</span><span class="o">*</span><span class="nb">max</span><span class="p">(</span> <span class="nb">abs</span><span class="p">(</span><span class="n">upper_limits</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">lower_limits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">numerical_derivative_factor</span><span class="o">*</span><span class="n">all_fitpararrays</span><span class="p">[</span><span class="n">number_of_fitparameters</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="n">all_fitpararrays</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">+=</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>


        <span class="c1">##Calculate the residuals and cost (e.g. difference between simulated and measured reflectivities) at each delta-step, in parallel</span>

        <span class="n">out</span><span class="o">=</span><span class="n">joblib</span><span class="o">.</span><span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">number_of_cores</span><span class="p">)(</span><span class="n">joblib</span><span class="o">.</span><span class="n">delayed</span><span class="p">(</span><span class="n">residualandcostfunction</span><span class="p">)(</span> <span class="n">all_fitpararrays</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_fitparameters</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
        
        <span class="k">if</span><span class="p">(</span><span class="n">ite</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
            <span class="c1">#Calculate the first fit error</span>
            <span class="n">fiterror1</span><span class="o">=</span> <span class="n">out</span><span class="p">[</span> <span class="n">number_of_fitparameters</span> <span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1">#in first iteration: create the matrix DT to stores all the residuals derivatives</span>
            <span class="n">number_of_datapoints</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">DT</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">number_of_fitparameters</span><span class="p">,</span><span class="n">number_of_datapoints</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fiterror1</span><span class="o">=</span><span class="n">fiterror2</span>
        <span class="c1">#Calculate the derivative of the reflectivity</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_fitparameters</span><span class="p">):</span>
            <span class="n">DT</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span> <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">out</span><span class="p">[</span><span class="n">number_of_fitparameters</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span><span class="o">/</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1">##Calculate the gradient</span>
        
        <span class="n">A</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">DT</span><span class="p">,</span><span class="n">DT</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">b</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">DT</span><span class="p">,(</span><span class="n">out</span><span class="p">[</span><span class="n">number_of_fitparameters</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">T</span> <span class="p">)</span>

        <span class="c1">#If one of the derivatives is entirely zero, the fit parameter is essentially meaningless. That may happen for a number of reasons. However, Gauss-Newton fails for this case.</span>
        <span class="c1">#If strict=False make it work nevertheless</span>
        <span class="n">irrelevantparameterlist</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_fitparameters</span><span class="p">):</span>
            <span class="k">if</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
                    <span class="nb">print</span> <span class="s2">&quot;WARNING! No gradient component&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;! Singular matrix!</span><span class="se">\n</span><span class="s2"> Try </span><span class="se">\&#39;</span><span class="s2">strict=False</span><span class="se">\&#39;</span><span class="s2"> for less rigorous treatment.&quot;</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">Exception</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">irrelevantparameterlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">strict</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">irrelevantparameterlist</span><span class="o">==</span><span class="p">[]:</span>
            <span class="c1">#remove the elements corresponding to the irrelevant parameters</span>
            <span class="nb">print</span> <span class="s2">&quot;WARNING! Parameters &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">irrelevantparameterlist</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; are locally irrelevant (no gradient component) and will be ignored for this iteration.&quot;</span>
            <span class="n">DT_reduced</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">DT</span><span class="p">,</span><span class="n">irrelevantparameterlist</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">A</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">DT_reduced</span><span class="p">,</span><span class="n">DT_reduced</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">b</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">irrelevantparameterlist</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1">#Solve this system of equations to calculate the descent vector that is used for large steps</span>
        <span class="n">DTr</span><span class="o">=</span><span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">sym_pos</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1">#This is another good descent vector that is used for small steps</span>
        <span class="n">DTr2</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">number_of_fitparameters</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">irrelevantparameterlist</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_fitparameters</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">irrelevantparameterlist</span><span class="p">)):</span>
            <span class="n">DTr2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">strict</span><span class="p">:</span>
            <span class="c1">#fill components of the descent vector which correspond to irrelevant parameters, with zero</span>
            <span class="k">for</span> <span class="n">parind</span> <span class="ow">in</span> <span class="n">irrelevantparameterlist</span><span class="p">:</span>
                <span class="n">DTr</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">DTr</span><span class="p">,</span><span class="n">parind</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">DTr2</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">DTr2</span><span class="p">,</span><span class="n">parind</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
            
        <span class="n">ite</span><span class="o">+=</span><span class="mi">1</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PyXMRTool 0.9 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Yannic Utz.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.5.
    </div>
  </body>
</html>