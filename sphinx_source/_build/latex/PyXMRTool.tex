%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{PyXMRTool Documentation}
\date{Jul 17, 2018}
\release{0.9}
\author{Yannic Utz}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}



\chapter{todo: Introduction}
\label{\detokenize{intro:todo-introduction}}\label{\detokenize{intro::doc}}
to be written


\chapter{todo: Installation}
\label{\detokenize{install:todo-installation}}\label{\detokenize{install::doc}}
to be written


\chapter{todo: Usage}
\label{\detokenize{usage:todo-usage}}\label{\detokenize{usage::doc}}
to be written


\chapter{API}
\label{\detokenize{api:api}}\label{\detokenize{api::doc}}

\section{Module \sphinxtitleref{Parameters}}
\label{\detokenize{modules-api/parameters:module-Parameters}}\label{\detokenize{modules-api/parameters:module-parameters}}\label{\detokenize{modules-api/parameters::doc}}\index{Parameters (module)}
Provide an easy and transparent handling of fit parameters
\index{Parameter (class in Parameters)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/parameters:Parameters.Parameter}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Parameters.}}\sphinxbfcode{\sphinxupquote{Parameter}}}{\emph{value=None}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

Base class for parameter. Contains read-only property ‘value’. Supports creation of dependent parameters by arithmetic operations.
\index{\_\_init\_\_() (Parameters.Parameter method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/parameters:Parameters.Parameter.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{value=None}}{}
Initialize and check if numeric type.

\end{fulllineitems}

\index{getValue() (Parameters.Parameter method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/parameters:Parameters.Parameter.getValue}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getValue}}}{\emph{fitpararray=None}}{}
Returns the value. fitpararray is not used and only there to make this function forward compatible with the Fitparameter class and with dependent parameters.

\end{fulllineitems}


\end{fulllineitems}

\index{Fitparameter (class in Parameters)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/parameters:Parameters.Fitparameter}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Parameters.}}\sphinxbfcode{\sphinxupquote{Fitparameter}}}{\emph{name}, \emph{fixed=0}, \emph{start\_val=None}, \emph{lower\_lim=None}, \emph{upper\_lim=None}}{}
Bases: {\hyperref[\detokenize{modules-api/parameters:Parameters.Parameter}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Parameters.Parameter}}}}}

Contains name, starting value and limits of a parameter and knows how to make the parameter value out of an array of fitparameters if it is attached to a ParameterPool.
\index{\_\_init\_\_() (Parameters.Fitparameter method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/parameters:Parameters.Fitparameter.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{name}, \emph{fixed=0}, \emph{start\_val=None}, \emph{lower\_lim=None}, \emph{upper\_lim=None}}{}
Initialize a fitparameter at least with a name.

If ‘fixed=1’,the parameter will not be varied during a fit routine and the limits are not necessary.

\end{fulllineitems}

\index{fix() (Parameters.Fitparameter method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/parameters:Parameters.Fitparameter.fix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{fix}}}{}{}
Fix parameter during fitting.

\end{fulllineitems}

\index{unfix() (Parameters.Fitparameter method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/parameters:Parameters.Fitparameter.unfix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{unfix}}}{}{}
Set parameter as variable during fitting.

\end{fulllineitems}

\index{getValue() (Parameters.Fitparameter method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/parameters:Parameters.Fitparameter.getValue}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getValue}}}{\emph{fitpararray}}{}
Return the value of the parameter corresponding to the given array of values.

\end{fulllineitems}

\index{name (Parameters.Fitparameter attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/parameters:Parameters.Fitparameter.name}}\pysigline{\sphinxbfcode{\sphinxupquote{name}}}
\end{fulllineitems}

\index{fixed (Parameters.Fitparameter attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/parameters:Parameters.Fitparameter.fixed}}\pysigline{\sphinxbfcode{\sphinxupquote{fixed}}}
\end{fulllineitems}

\index{start\_val (Parameters.Fitparameter attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/parameters:Parameters.Fitparameter.start_val}}\pysigline{\sphinxbfcode{\sphinxupquote{start\_val}}}
\end{fulllineitems}

\index{lower\_lim (Parameters.Fitparameter attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/parameters:Parameters.Fitparameter.lower_lim}}\pysigline{\sphinxbfcode{\sphinxupquote{lower\_lim}}}
\end{fulllineitems}

\index{upper\_lim (Parameters.Fitparameter attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/parameters:Parameters.Fitparameter.upper_lim}}\pysigline{\sphinxbfcode{\sphinxupquote{upper\_lim}}}
\end{fulllineitems}

\index{index (Parameters.Fitparameter attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/parameters:Parameters.Fitparameter.index}}\pysigline{\sphinxbfcode{\sphinxupquote{index}}}
\end{fulllineitems}

\index{complex (Parameters.Fitparameter attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/parameters:Parameters.Fitparameter.complex}}\pysigline{\sphinxbfcode{\sphinxupquote{complex}}}
\end{fulllineitems}


\end{fulllineitems}

\index{ParameterPool (class in Parameters)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/parameters:Parameters.ParameterPool}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Parameters.}}\sphinxbfcode{\sphinxupquote{ParameterPool}}}{\emph{parfilename=None}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

Collects a pool of Parameter objects and connects them with a parameter file.
\index{\_\_init\_\_() (Parameters.ParameterPool method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/parameters:Parameters.ParameterPool.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{parfilename=None}}{}
Initialize a new ParameterPool. Read parameter initialisation from file ‘parfilename’.

As soon as you connect a parameter file to the pool, its initialisation values have priority 
over local initialisations with self.newParameter(“name”,fixed,start\_value, lower\_lim, upper\_lim).

\end{fulllineitems}

\index{newParameter() (Parameters.ParameterPool method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/parameters:Parameters.ParameterPool.newParameter}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{newParameter}}}{\emph{name}, \emph{fixed=0}, \emph{start\_val=None}, \emph{lower\_lim=None}, \emph{upper\_lim=None}}{}
Create a New Parameter and return a reference to it or return the reference to an existing one.

\end{fulllineitems}

\index{getParameter() (Parameters.ParameterPool method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/parameters:Parameters.ParameterPool.getParameter}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getParameter}}}{\emph{name}}{}
Return existing parameter with name ‘name’ or return ‘None’ if not existing.

\end{fulllineitems}

\index{readFromFile() (Parameters.ParameterPool method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/parameters:Parameters.ParameterPool.readFromFile}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{readFromFile}}}{\emph{parfilename}}{}
Read parameters from file, append them to the pool or overwrite existing once.

Lines in the parameter file should be in the format: \textless{}start\_value\textgreater{}  \textless{}fixed\textgreater{} \textless{}lower\_limit\textgreater{} \textless{}upper\_limit\textgreater{} \textless{}name\textgreater{}
Lines starting with ‘\#’ are ignored.

\end{fulllineitems}

\index{writeToFile() (Parameters.ParameterPool method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/parameters:Parameters.ParameterPool.writeToFile}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{writeToFile}}}{\emph{parfilename}, \emph{fitpararray=None}}{}
Write parameters to file.

Can be used to create a template for a parameter initialisation file or to store parameters after fitting.
If ‘fitpararray is’ is given, these values are used as start\_values. Else the stored start\_values are used

\end{fulllineitems}

\index{getStartLowerUpper() (Parameters.ParameterPool method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/parameters:Parameters.ParameterPool.getStartLowerUpper}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getStartLowerUpper}}}{}{}
Return a tupel of arrays of parameter start values and limits in the order of occurence in the pool (order of parameter creation) of parameters which are not fixed. Real parameters first, then the complex ones.

\end{fulllineitems}

\index{setStartValues() (Parameters.ParameterPool method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/parameters:Parameters.ParameterPool.setStartValues}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setStartValues}}}{\emph{fitvalues}}{}
Set the start values of all parameters which are not fixed in the order of occurence in the pool (order of parameter creation). First real and then complex ones.

Can be used befor writeToFile() if you want to write out results of a fit to a file.

\end{fulllineitems}

\index{getFitArrayLen() (Parameters.ParameterPool method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/parameters:Parameters.ParameterPool.getFitArrayLen}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getFitArrayLen}}}{}{}
\end{fulllineitems}

\index{getNames() (Parameters.ParameterPool method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/parameters:Parameters.ParameterPool.getNames}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getNames}}}{}{}
Return the names of all registered Fitparameters as a list in the same order they should be in the fitpararrays.

\end{fulllineitems}


\end{fulllineitems}



\section{Module \sphinxtitleref{SampleRepresentation}}
\label{\detokenize{modules-api/samplerepresentation:module-SampleRepresentation}}\label{\detokenize{modules-api/samplerepresentation:module-samplerepresentation}}\label{\detokenize{modules-api/samplerepresentation::doc}}\index{SampleRepresentation (module)}
Deals with the sample representation for simulation of the reflectivity.
\index{Heterostructure (class in SampleRepresentation)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/samplerepresentation:SampleRepresentation.Heterostructure}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{SampleRepresentation.}}\sphinxbfcode{\sphinxupquote{Heterostructure}}}{\emph{number\_of\_layers=0}, \emph{multilayer\_structure=None}}{}
Represents a heterostructructure as a stack of layers.

In contrast to Martin’s list of Layer-type objects, this class contains all information also for different energies.
\index{\_\_init\_\_() (SampleRepresentation.Heterostructure method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/samplerepresentation:SampleRepresentation.Heterostructure.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{number\_of\_layers=0}, \emph{multilayer\_structure=None}}{}
Create heterostructructure object.

‘number\_of\_layers’ gives the number of different layers.
With ‘multilayer\_structure’ multilayers which contain identical layers several times can be defined.
This can be defined by as a list containing the indices of layer from the lowest (e.g. substrate) to the highest (top layer, hit first by the beam).
Default is ‘{[}0,1,2,3, …,number\_of\_layers-1{]}’. Multilayer syntax is e.g. ‘{[}0,1,2,{[}100,{[}3,4,5,6{]}{]},7,.,1,..{]}’ which repeats 100 times the sequence of
layers 3,4,5,6 in between 2 and 7 and later on layer 1 is repeated once.

\end{fulllineitems}

\index{setLayout() (SampleRepresentation.Heterostructure method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/samplerepresentation:SampleRepresentation.Heterostructure.setLayout}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setLayout}}}{\emph{number\_of\_layers}, \emph{multilayer\_structure=None}}{}
Change the layout of the heterostructure.

See constructor for details. Only difference is: you cannot make changes which would remove layers.

\end{fulllineitems}

\index{setLayer() (SampleRepresentation.Heterostructure method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/samplerepresentation:SampleRepresentation.Heterostructure.setLayer}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setLayer}}}{\emph{index}, \emph{layer}}{}
Place ‘layer’ (instance of LayerObject) at position ‘index’ (counting from 0, starting from the bottom or according to ‘multilayer\_structure’).

\end{fulllineitems}

\index{getLayer() (SampleRepresentation.Heterostructure method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/samplerepresentation:SampleRepresentation.Heterostructure.getLayer}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getLayer}}}{\emph{index}}{}
Return the instance of LayerObject which is placed at position ‘index’ (counting from 0, starting from the bottom or according to ‘multilayer\_structure’).

\end{fulllineitems}

\index{getTotalLayer() (SampleRepresentation.Heterostructure method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/samplerepresentation:SampleRepresentation.Heterostructure.getTotalLayer}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getTotalLayer}}}{\emph{index}}{}
Return the instance of LayerObject which is placed at position ‘index’ (counting from 0, starting from the bottom, even if a latter sequence is repeated with help of ‘multilayer\_structure’).

\end{fulllineitems}

\index{removeLayer() (SampleRepresentation.Heterostructure method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/samplerepresentation:SampleRepresentation.Heterostructure.removeLayer}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{removeLayer}}}{\emph{index}}{}
Remove the instance of LayerObject which is placed at position ‘index’ (counting from 0, starting from the bottom from the  heterostructructure or according to ‘multilayer\_structure’).

‘index’ can also be a list of indices.
BEWARE: The instance of LayerObject itself and the corresdonding Parameters are not deleted!

\end{fulllineitems}

\index{getSingleEnergyStructure() (SampleRepresentation.Heterostructure method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/samplerepresentation:SampleRepresentation.Heterostructure.getSingleEnergyStructure}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getSingleEnergyStructure}}}{\emph{fitpararray}, \emph{energy=None}}{}
Return list of layers (layer type from Pythonreflectivity) which can be directly used as input for ‘Pythonreflectivity.Reflectivity( )’

‘energy’ in units of eV

\end{fulllineitems}

\index{N (SampleRepresentation.Heterostructure attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/samplerepresentation:SampleRepresentation.Heterostructure.N}}\pysigline{\sphinxbfcode{\sphinxupquote{N}}}
Return number of different layers (i.e. number of different indices).

\end{fulllineitems}

\index{N\_total (SampleRepresentation.Heterostructure attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/samplerepresentation:SampleRepresentation.Heterostructure.N_total}}\pysigline{\sphinxbfcode{\sphinxupquote{N\_total}}}
Return total number of layers (counting also multiple use of the same layer according to ‘multilayer\_structure’).

\end{fulllineitems}


\end{fulllineitems}

\index{LayerObject (class in SampleRepresentation)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/samplerepresentation:SampleRepresentation.LayerObject}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{SampleRepresentation.}}\sphinxbfcode{\sphinxupquote{LayerObject}}}{\emph{chitensor=None}, \emph{d=None}, \emph{sigma=None}, \emph{magdir='0'}}{}
Base class for all layer objects as the common interface. Speciallized implementation should inherit from this class.

It handels the basic properties of
\index{\_\_init\_\_() (SampleRepresentation.LayerObject method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/samplerepresentation:SampleRepresentation.LayerObject.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{chitensor=None}, \emph{d=None}, \emph{sigma=None}, \emph{magdir='0'}}{}
Creates a new Layer.

‘d’ is its thickness, ‘sigma’ is the roughness of its upper surface, ‘chitensor’ is its electric susceptibility tensor, and ‘magdir’ gives the magnetization directrion for MOKE
‘d’, ‘sigma’ ,and the entries of ‘chitensor’ are expected to be an instances of a “Parameter” class (also “Fitparamter”).
‘d’ and ‘sigma’ are both of dimension length. You are free to choose whatever unit you want, but use the same for every length troughout the project.
‘chitensor’ is a list of either  1,3, 4 or 9 elements (see also documentation for Pythonreflectivity). Each of these elements is supposed to be of type Parameter or of a derived class.
{[}chi{]} sets chi\_xx = chi\_yy = chi\_zz = chi
{[}chi\_xx,chi\_yy,chi\_z{]} sets  chi\_xx,chi\_yy,chi\_zz, others are zero
{[}chi\_xx,chi\_yy,chi\_z,chi\_g{]} sets  chi\_xx,chi\_yy,chi\_zz and depending on ‘magdir’ chi\_yz=-chi\_zy=chi\_g (if ‘x’), chi\_xz=-chi\_zx=chi\_g (if ‘y’) or chi\_xz=-chi\_zx=chi\_g (if ‘z’)
{[}chi\_xx,chi\_xy,chi\_xz,chi\_yx,chi\_yy,chi\_yz,chi\_zx,chi\_zy,chi\_zz{]} sets all the corresdonding elements

\end{fulllineitems}

\index{getChi() (SampleRepresentation.LayerObject method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/samplerepresentation:SampleRepresentation.LayerObject.getChi}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getChi}}}{\emph{fitpararray}, \emph{energy=None}}{}
Return the chitensor as a list of numbers for a certain energy.

For the base implementation of class ‘LayerObject’ the parameter ‘energy’ is not used. But it may be used by derived classes like ‘AtomLayerObject’.
‘energy’ in units of eV.

\end{fulllineitems}

\index{getD() (SampleRepresentation.LayerObject method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/samplerepresentation:SampleRepresentation.LayerObject.getD}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getD}}}{\emph{fitpararray}}{}
Return the thickness d as a an actual number.

The thickness is given in the unit of length you chose. You are free to choose whatever unit you want, but use the same for every length troughout the project.

\end{fulllineitems}

\index{getSigma() (SampleRepresentation.LayerObject method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/samplerepresentation:SampleRepresentation.LayerObject.getSigma}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getSigma}}}{\emph{fitpararray}}{}
Return sigma as a an actual number.

The thickness is given in the unit of length you chose. You are free to choose whatever unit you want, but use the same for every length troughout the project.

\end{fulllineitems}

\index{getMagDir() (SampleRepresentation.LayerObject method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/samplerepresentation:SampleRepresentation.LayerObject.getMagDir}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getMagDir}}}{\emph{fitpararray=None}}{}
Return magdir.

fitpararray is not used and just there to give a common interface. mMybe derived classes will have a benefit from it.

\end{fulllineitems}


\end{fulllineitems}

\index{ModelChiLayerObject (class in SampleRepresentation)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/samplerepresentation:SampleRepresentation.ModelChiLayerObject}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{SampleRepresentation.}}\sphinxbfcode{\sphinxupquote{ModelChiLayerObject}}}{\emph{chitensorfunction}, \emph{d=None}, \emph{sigma=None}, \emph{magdir='0'}}{}
Speciallized Layer to deal with a Suszeptibility Tensor (Chi) which is modelled as function of energy.

Beware: The property chitensor is here supposed to be a function.
\index{\_\_init\_\_() (SampleRepresentation.ModelChiLayerObject method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/samplerepresentation:SampleRepresentation.ModelChiLayerObject.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{chitensorfunction}, \emph{d=None}, \emph{sigma=None}, \emph{magdir='0'}}{}
Creates a new ModelChiLayer.

‘d’ is its thickness, ‘sigma’ is the roughness of its upper surface,  and ‘magdir’ gives the magnetization directrion for MOKE
‘d’, ‘sigma’ ,and the entries of ‘chitensor’ are expected to be an instances of a “Parameter” class (also “Fitparamter”).
‘d’ and ‘sigma’ are both of dimension length. You are free to choose whatever unit you want, but use the same for every length troughout the project.
‘chitensorfunction’ should be a function of two parameters (fitpararray,energy) and should return a list of either  1,3, 4 or 9 elements (see also documentation for Pythonreflectivity). 
Each of these elements is supposed to be a number (real or imaginary).
{[}chi{]} sets chi\_xx = chi\_yy = chi\_zz = chi
{[}chi\_xx,chi\_yy,chi\_z{]} sets  chi\_xx,chi\_yy,chi\_zz, others are zero
{[}chi\_xx,chi\_yy,chi\_z,chi\_g{]} sets  chi\_xx,chi\_yy,chi\_zz and depending on ‘magdir’ chi\_yz=-chi\_zy=chi\_g (if ‘x’), chi\_xz=-chi\_zx=chi\_g (if ‘y’) or chi\_xz=-chi\_zx=chi\_g (if ‘z’)
{[}chi\_xx,chi\_xy,chi\_xz,chi\_yx,chi\_yy,chi\_yz,chi\_zx,chi\_zy,chi\_zz{]} sets all the corresdonding elements

\end{fulllineitems}

\index{getChi() (SampleRepresentation.ModelChiLayerObject method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/samplerepresentation:SampleRepresentation.ModelChiLayerObject.getChi}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getChi}}}{\emph{fitpararray}, \emph{energy}}{}
Return the chitensor as a list of numbers for a certain energy.

‘energy’ in units of eV.

\end{fulllineitems}


\end{fulllineitems}

\index{AtomLayerObject (class in SampleRepresentation)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/samplerepresentation:SampleRepresentation.AtomLayerObject}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{SampleRepresentation.}}\sphinxbfcode{\sphinxupquote{AtomLayerObject}}}{\emph{densitydict=\{\}}, \emph{d=None}, \emph{sigma=None}, \emph{magdir='0'}, \emph{densityunitfactor=1.0}}{}
Speciallized Layer to deal with compositions of Atoms and their energy dependent formfactors (which can be obtained from absorption spectra).

Especially usefull to deal with atomic layers, but can also be used for bulk.
The atoms and their formfactors have to be registered a the class (with registerAtom) before they can be used to instantiate a new AtomLayerObject.
The atom density can be plotted with plotAtomDensity() (see convenience functions).
Density in mol/cm\$\textasciicircum{}3\$ (as long as no densityunitfactor is applied)
\index{\_\_init\_\_() (SampleRepresentation.AtomLayerObject method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/samplerepresentation:SampleRepresentation.AtomLayerObject.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{densitydict=\{\}}, \emph{d=None}, \emph{sigma=None}, \emph{magdir='0'}, \emph{densityunitfactor=1.0}}{}
Create an AtomLayerObject.

‘densitydict’ ist a dictionary which contains atom names (strings, must agree with before registered atoms) and densities (must be instances of the Parameter class or derived classes).
For the other parameters see ‘LayerObject’.

If the densities in densitydict are measured in another unit than mol/cm\textasciicircum{}3, state the ‘densityunitfactor’ which translates your generic density to the one used internally.
I.e.    rho\_in\_mol\_per\_cubiccm = densityunitfactor * rho\_in\_whateverunityouwant

\end{fulllineitems}

\index{getDensitydict() (SampleRepresentation.AtomLayerObject method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/samplerepresentation:SampleRepresentation.AtomLayerObject.getDensitydict}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getDensitydict}}}{\emph{fitpararray=None}}{}
Return the density dictionary either with evaluated paramters (needs fitpararray) or with the raw ‘Parameter’ objects (use fitparraray=None).

\end{fulllineitems}

\index{getChi() (SampleRepresentation.AtomLayerObject method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/samplerepresentation:SampleRepresentation.AtomLayerObject.getChi}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getChi}}}{\emph{fitpararray}, \emph{energy}}{}
Return the chitensor as a list numbers of  for a certain energy.

‘energy’ in units of eV.

\end{fulllineitems}

\index{registerAtom() (SampleRepresentation.AtomLayerObject class method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/samplerepresentation:SampleRepresentation.AtomLayerObject.registerAtom}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{registerAtom}}}{\emph{name}, \emph{formfactor}}{}
Register an atom for later use to instantiate an AtomLayerObject.

‘formfactor’ as to be an instance of ‘Formfactor’ or of a derived class.

\end{fulllineitems}

\index{getAtom() (SampleRepresentation.AtomLayerObject class method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/samplerepresentation:SampleRepresentation.AtomLayerObject.getAtom}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{getAtom}}}{\emph{name}}{}
Return the Formfactor object registered for Atom ‘name’.

\end{fulllineitems}

\index{getAtomNames() (SampleRepresentation.AtomLayerObject class method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/samplerepresentation:SampleRepresentation.AtomLayerObject.getAtomNames}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{getAtomNames}}}{}{}
Return a list of names of registered atoms.

\end{fulllineitems}


\end{fulllineitems}

\index{Formfactor (class in SampleRepresentation)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/samplerepresentation:SampleRepresentation.Formfactor}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{SampleRepresentation.}}\sphinxbfcode{\sphinxupquote{Formfactor}}}
Base class to deal with energy-dependent atomic form-factors.

This base class is an abstract class an cannot be used directly.
The user should derive from this class if he wants to build his own models.
\index{\_\_init\_\_() (SampleRepresentation.Formfactor method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/samplerepresentation:SampleRepresentation.Formfactor.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{}{}
x.\_\_init\_\_(…) initializes x; see help(type(x)) for signature

\end{fulllineitems}

\index{getFF() (SampleRepresentation.Formfactor method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/samplerepresentation:SampleRepresentation.Formfactor.getFF}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getFF}}}{\emph{energy}, \emph{fitpararray=None}}{}
Return the formfactor for ‘energy’ corresponding to fitpararray (if it depends on it).

‘energy’ in units of eV.

\end{fulllineitems}


\end{fulllineitems}

\index{FFfromFile (class in SampleRepresentation)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/samplerepresentation:SampleRepresentation.FFfromFile}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{SampleRepresentation.}}\sphinxbfcode{\sphinxupquote{FFfromFile}}}{\emph{filename}, \emph{linereaderfctn=None}, \emph{energyshift=\textless{}Parameters.Parameter object\textgreater{}}}{}
Class to deal with energy-dependent atomic form-factors which are tabulated in files.
\index{\_\_init\_\_() (SampleRepresentation.FFfromFile method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/samplerepresentation:SampleRepresentation.FFfromFile.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{filename}, \emph{linereaderfctn=None}, \emph{energyshift=\textless{}Parameters.Parameter object\textgreater{}}}{}
Initializes the FFfromFile object with the data from filename.

The ‘linereaderfctn’ is used to convert one line from the text file to data.
It should be a function which takes a string and returns a tuple or list of 10 values: (energy,f\_xx,f\_xy,f\_xz,f\_yx,f\_yy,f\_yz,f\_zx,f\_zy,f\_zz) 
‘energy’ in units of eV, formfactors in units of “e/atom” (dimensionless)
It can also return ‘None’ if it detects a comment line.
You can use FFfromFile.createLinereader to get a standard function, which just reads this array as whitespace seperated from the line.

‘energyshift’ has to be an instance of ‘Paramater’ or of a derived class. It can be used to specify a fittable energyshift between
the energy-dependent formfactor from filename and the ‘real’ one in the reflectivity measurement. So the formfactor delivered from getFF() 
will not be formfactor\_from\_file(E) but formfactor\_from\_file(E+energyshift).

\end{fulllineitems}

\index{createLinereader() (SampleRepresentation.FFfromFile static method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/samplerepresentation:SampleRepresentation.FFfromFile.createLinereader}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{createLinereader}}}{\emph{complex\_numbers=True}}{}
Return the standard linereader function.

This standard linereader function reads energy and complex elements of the formfactor tensor as a whitespace-seperated list (i.e. 10 numbers) and interpretes ‘\#’ as comment sign.
If complex\_numbers==0 then the reader reads real and imaginary part of every element sepeately, i.e. every line has to consist of 19 numbers seperated by whitespaces.

\end{fulllineitems}

\index{getFF() (SampleRepresentation.FFfromFile method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/samplerepresentation:SampleRepresentation.FFfromFile.getFF}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getFF}}}{\emph{energy}, \emph{fitpararray=None}}{}
Return the (energy-shifted )formfactor for ‘energy’ as an interpolation between the stored values from file as 1-D numpy array.

‘energy’ in units of eV.
‘fitpararray’ is actually only needed when an energyshift has been defined.

\end{fulllineitems}


\end{fulllineitems}

\index{plotAtomDensity() (in module SampleRepresentation)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/samplerepresentation:SampleRepresentation.plotAtomDensity}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SampleRepresentation.}}\sphinxbfcode{\sphinxupquote{plotAtomDensity}}}{\emph{hs}, \emph{fitpararray}, \emph{colormap={[}{]}}, \emph{atomnames=None}}{}
Make a plot of the atom densities of all AtomLayerObjects contained in the ‘Heterostructure’ ‘hs’ corresdonding to the ‘fitpararray’ and return the plotted information.

You can  define the colors of the bars. Just give a list of matplotlib color names. They will be used in the given order.
You can define which atoms you want to plot or in which order. Give ‘atomnames’ as a list of strings. If atomnames is not given, the bars will have different width, such that overlapped bars can be seen.

\end{fulllineitems}

\index{KramersKronig() (in module SampleRepresentation)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/samplerepresentation:SampleRepresentation.KramersKronig}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SampleRepresentation.}}\sphinxbfcode{\sphinxupquote{KramersKronig}}}{\emph{energy}, \emph{absorption}}{}
Perform the Kramers Kronig transformation. Just a wrapper for the function Pythonreflectivity.KramersKroning(energy,absorption) from Martins Pythonreflectivity package.

‘energy’: an ordered list/array of L energies (in eV). The energies do not have to be envenly spaced, but they should be ordererd.
‘absorption’: a list/array of real numbers and length L with absorption data.

\end{fulllineitems}



\section{Module \sphinxtitleref{Experiment}}
\label{\detokenize{modules-api/experiment:module-Experiment}}\label{\detokenize{modules-api/experiment:module-experiment}}\label{\detokenize{modules-api/experiment::doc}}\index{Experiment (module)}
Deals the description of the experiment and brings experimental and simulated data together.
\index{ReflDataSimulator (class in Experiment)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/experiment:Experiment.ReflDataSimulator}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Experiment.}}\sphinxbfcode{\sphinxupquote{ReflDataSimulator}}}{\emph{mode}, \emph{length\_scale=1e-08}}{}
Holds the experimental data, simulates it according to the settings and fitparameters and can directly deliver chi\_square (which measures the difference between the data and the simulation with a certain parameter set.
\index{\_\_init\_\_() (Experiment.ReflDataSimulator method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/experiment:Experiment.ReflDataSimulator.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{mode}, \emph{length\_scale=1e-08}}{}
Initialize the ReflDataSimulator with a certain mode.
\begin{description}
\item[{‘mode’ can be:    ‘l’             - for linear polarized light, only reflectivity for sigma and pi polarization will be stored and simulated}] \leavevmode
‘c’             - for circular polarized light, only reflectivity for left circular and right circular polarization will be stored and simulated
‘x’             - for xmcd, only the difference between the reflectivity for right circular and left circular polarization will be stored and simulated
‘cx\textless{}xfactor\textgreater{}’   - for the reflections of circular pol. light and the xmcd signal (which should usually been calculated from the left and right circ. pol.) simultaniously
\begin{quote}

‘\textless{}xfactor\textgreater{}’ is optional and can be used to multiply the xmcd signal with this value. This can be usefull to give the xmcd more or less weight during fitting
e.g.   ‘cx20’ or ‘cx0.1’
\end{quote}

‘lL’,’cL’,
‘xL’,
‘cLx\textless{}xfactor\textgreater{}’, - as before, but instead of the corresponding reflectivities themselfs there logarithms are stored and simulated.

\end{description}

Define with ‘length\_scale’ in which units lengths are measured in your script. The unit is then ‘length\_scale’{\color{red}\bfseries{}*}meters. Standard is ‘length\_scale=10e-9’ which means nm.
It is important to define it here due to conversion between energies and wavelength.

\end{fulllineitems}

\index{ReadData() (Experiment.ReflDataSimulator method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/experiment:Experiment.ReflDataSimulator.ReadData}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ReadData}}}{\emph{files}, \emph{linereaderfunction}, \emph{energies=None}, \emph{angles=None}, \emph{filenamereaderfunction=None}, \emph{pointmodifierfunction=None}, \emph{headerlines=0}}{}
Read the data files and store the data corresponding to the ‘mode’ specified with instanciation.

This function enables a very flexible reading of the data files.
Logically this function uses data point which consist of the independent variables energy and angle, and the reflectivities as dependent variables (rsigmag,rpi,rleft,rright,xmcd).
So one point is specified by (energy,angle,rsigmag,rpi,rleft,rright,xmcd)  with energies in eV and angles in degrees.
Where this information comes from can differ.

At first, there are two different ways to specify the data files: Either a list of filenames (strings) or one foldername (string) of a folder containing all the data files (and only them!).

One possibility is that all information comes from the ‘linereaderfunction’. This function can be defined by the user (or created with createLinereader()).
It takes one line as a string and returns a list/tuple of real numbers (energy,angle,rsigma,rpi,rleft,rright,xmcd). Entries can also be ‘None’. The function will complain only if the needed information for the specified ‘mode’ is not delivered.

Sometimes, not all the information on independent variables can be obtained from single lines of the file. To specify an independent variable which is valid for complete files there are 3 different possibilities, which cannot be mixed:
Set the list ‘energies’: Only possible if ‘files’ is a list of filenames. Gives the energies which belong to the corresponding files (same order) as floats.
Set the list ‘angles’: Only possible if ‘files’ is a list of filenames. Gives the angles which belong to the corresponding files (same order) as floats.
Set ‘filenamereaderfunction’: Give a user-specified function to the function ‘ReadData()’. It should take a string (a filename without path), extract energy and/or angle out of it and return this as a tuple/list (energy,angle). Both entries can also be set to ‘None’, but their will be an exception if the information for the data points can also not be obtained from the linereaderfunction.

With the parameter ‘pointmodifierfunction’ you can hand over a functions which takes the list of independent and dependent variables of a single data point and returns a modified one.
Can be used e.g. if the data file contains qz values instead of angles. The ‘pointmodifierfunction’ can calculate the angles.
Of course you can also use a adopted linereaderfunction for this (if all necessary information can be found in one line of the data files).

‘headerlines’ specifies the number of lines which should be ignored in each file.

\end{fulllineitems}

\index{setModel() (Experiment.ReflDataSimulator method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/experiment:Experiment.ReflDataSimulator.setModel}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setModel}}}{\emph{heterostructure}, \emph{reflmodifierfunction=None}, \emph{MultipleScattering=True}, \emph{MagneticCutoff=1e-50}}{}
Set up the model for the simulation of the reflectivity data.

The simulation of the reflectivities is in prinicple done by using the information about the sample stored in heterostructure (of type SampleRepresentation.Heterostructure).
The reflectivities calculated by this are then given to the ‘reflmodifierfunction’ (takes one number or numpy array and the fitpararray; returns one number or numpy array). This funktion has to be defined 
by the user and can be used e.g. to multiply the reflectivity by a global number and/or to add a common background. To make these numbers fittable, use the fitparameters registerd at the ParamterPool
e.g
\begin{quote}

pp=Paramters.ParameterPool(“any\_parameterfile”)
…
b=pp.NewParameter(“background”)
m=pp.NewParameter(“multiplier”)
reflmodifierfunction=lambda r, fitpararray: b.getValue(fitpararra) + r * m.getValue(fitpararray)
\end{quote}

and give this function to ‘setModel’.
BEWARE: The reflmodifierfunction is called very often during fitting procedures. Make it performant!

With ‘MultipleScattering’ you can switch on (True) and off (False) the simulation of multiple scattering. False is 20 percent faster. Default is True. Has no effect on calculations that require the full matrix.

MagneticCutoff: If an off-diagonal element of chi (chi\_g) fulfills abs(chi\_g)\textless{}MagneticCutoff, it is set to zero. It defaults to 10e-50.

The last to parameters are directly passed to Pythonreflectivity.Reflectivity. See also the Documentation of Pythonreflectivity.

\end{fulllineitems}

\index{getLenDataFlat() (Experiment.ReflDataSimulator method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/experiment:Experiment.ReflDataSimulator.getLenDataFlat}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getLenDataFlat}}}{}{}
Return length of the flat data representation.

It will be the number of measured data points times 2 for mode “l” and “c”, only the number of measured data points for mode “x and the number of measured data points times 3 for mode cx”

\end{fulllineitems}

\index{getSimData() (Experiment.ReflDataSimulator method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/experiment:Experiment.ReflDataSimulator.getSimData}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getSimData}}}{\emph{fitpararray}}{}
Return simulated data according to the bevor set-up model and the parameter values given with fitpararray.

\end{fulllineitems}

\index{getExpData() (Experiment.ReflDataSimulator method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/experiment:Experiment.ReflDataSimulator.getExpData}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getExpData}}}{}{}
Return experimental data in the shape in which it is stored internally.

\end{fulllineitems}

\index{getSSR() (Experiment.ReflDataSimulator method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/experiment:Experiment.ReflDataSimulator.getSSR}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getSSR}}}{\emph{fitpararray}}{}
Return sum of squared residuals.

\end{fulllineitems}

\index{getResidualsSSR() (Experiment.ReflDataSimulator method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/experiment:Experiment.ReflDataSimulator.getResidualsSSR}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getResidualsSSR}}}{\emph{fitpararray}}{}
Return tuple: array of differences between simulated and measured data, sum of squared residuals.

\end{fulllineitems}

\index{plotData() (Experiment.ReflDataSimulator method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/experiment:Experiment.ReflDataSimulator.plotData}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plotData}}}{\emph{fitpararray}, \emph{simcolor='r'}, \emph{expcolor='b'}, \emph{simlabel='simulated'}, \emph{explabel='experimental'}}{}
Plot simulated and experimental Data.

This function generates a plot at the first call and refreshes it if called again.

‘simcolor’ and ‘expcolor’ are supposed to be strings which specify a color for the plotting with pyplot (see \sphinxurl{https://matplotlib.org/users/colors.html}).
Defaults are red and blue.
‘simlabel’ and ‘explabel’ are the labels shown in the legend of the plot.

\end{fulllineitems}

\index{setMode() (Experiment.ReflDataSimulator method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/experiment:Experiment.ReflDataSimulator.setMode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setMode}}}{\emph{mode}}{}
Change the mode after instanciation.

Be carefull with this function. Errors can occur if the mode does not fit to the available information in the data files.
\begin{description}
\item[{‘mode’ can be:    ‘l’             - for linear polarized light, only reflectivity for sigma and pi polarization will be stored and simulated}] \leavevmode
‘c’             - for circular polarized light, only reflectivity for left circular and right circular polarization will be stored and simulated
‘x’             - for xmcd, only the difference between the reflectivity for right circular and left circular polarization will be stored and simulated
‘cx\textless{}xfactor\textgreater{}’   - for the reflections of circular pol. light and the xmcd signal (which should usually been calculated from the left and right circ. pol.) simultaniously
\begin{quote}

‘\textless{}xfactor\textgreater{}’ is optional and can be used to multiply the xmcd signal with this value. This can be usefull to give the xmcd more or less weight during fitting
e.g.   ‘cx20’ or ‘cx0.1’
\end{quote}

‘lL’,’cL’,
‘xL’,
‘cLx\textless{}xfactor\textgreater{}’, - as before, but instead of the corresponding reflectivities themselfs there logarithms are stored and simulated.

\end{description}

\end{fulllineitems}

\index{createLinereader() (Experiment.ReflDataSimulator static method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/experiment:Experiment.ReflDataSimulator.createLinereader}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{createLinereader}}}{\emph{energy\_column=None}, \emph{angle\_column=None}, \emph{rsigma\_column=None}, \emph{rpi\_column=None}, \emph{rleft\_column=None}, \emph{rright\_column=None}, \emph{xmcd\_column=None}, \emph{commentsymbol='\#'}}{}
Return a linereader function which can read lines from whitespace-seperated files and returns lists of real numbers {[}energy,angle,rsigma,rpi,rleft,rright,xmcd{]} (or None).

With the parameters ‘…\_column’ you can determin wich column is interpreted how.
Column numbers are starting from 0.

\end{fulllineitems}


\end{fulllineitems}



\section{Module \sphinxtitleref{Fitters}}
\label{\detokenize{modules-api/fitters:module-Fitters}}\label{\detokenize{modules-api/fitters:module-fitters}}\label{\detokenize{modules-api/fitters::doc}}\index{Fitters (module)}
Contains different optimization algorithms designed for to fit reflectivity data.
They take advantage of parallelization to be used on multiprocessor system.

The algorithms are developed by Martin Zwiebel and I just adopted them to PyXMRTool.
More information can be found in the PhD thesis of Martin Zwiebler.
\index{Evolution() (in module Fitters)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/fitters:Fitters.Evolution}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fitters.}}\sphinxbfcode{\sphinxupquote{Evolution}}}{}{}
Evolutionary fit algorithm. Slow but good in finding the global minimum.
Return the optimized parameter set and the coresponding value of the costfunction.
\begin{description}
\item[{‘costfunction’ should usally be the method ‘getSSR’ of an instance of ‘ReflDataSimulator’ (returns the sum of squared residuals of i.e. the reflectivities or logarithms of reflectivities).}] \leavevmode
Can also be any other function which takes the array of fit parameters and returns one real value should be minimized by ‘Evolution’.

\end{description}

(‘startfitparameters’,’lower\_limits’,’upper\_limits): tuple/list of arrays/lists of start values/lower limits/upper limits for the fit parameters.
‘iterations’: number of iterations
‘number\_of\_cores’: number of jobs used in parallel. Best performance when set to the number of available cores on your computer.
‘generation\_size’:    Use this many individual fit parameter sets in each step
‘mutation\_strength’ Mutates by adding this factor times (upper\_limit - lower\_limit)  \textendash{}\textgreater{} use rather small values 
‘elite’ Remember the best individuals for the next generation
‘parent\_percentage’ \#Take this subset for reproduction

If ‘control\_file’ is given, you can abort the optimization routine by writing “terminate 1” to the beginning of its first line.

If ‘plotfunction’ is given, it will be used to plot the current state of fitting (simulated data with currently best parameter set) after every iteration. It should take only one parameter: the array of fitparameters.
\begin{description}
\item[{This Evolutionary algorithm is mainly the same as Martins. Only the rule for mutation has changed:}] \leavevmode
Martin: children{[}i{]}=children{[}i{]} * (1 + s * random float(-1,1))
I:      children{[}i{]}=children{[}i{]} + s * random float(-1,1)*(upper\_limits-lower\_limits)

\end{description}

\end{fulllineitems}

\index{Levenberg\_Marquardt\_Fitter() (in module Fitters)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{modules-api/fitters:Fitters.Levenberg_Marquardt_Fitter}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fitters.}}\sphinxbfcode{\sphinxupquote{Levenberg\_Marquardt\_Fitter}}}{}{}
Modified Levenberg-Marquard algorithm (see PhD thesis of Martin Zwiebler). Good convergence, but might end up in a local mininum.
Return the optimized parameter set and the coresponding value of the costfunction.
\begin{description}
\item[{‘residualandcostfunction’ should usally be the method ‘getResidualsSSR’ of an instance of ‘ReflDataSimulator’. Can also be any other function which takes the array of fit parameters and returns a tuple of }] \leavevmode
1.) a list of residuals (will be used to determine derivatives) 2.) a value of the costfunction which should be minimized (usually the sum of squared residuals)

\end{description}

(‘startfitparameters’,’lower\_limits’,’upper\_limits): tuple/list of arrays/lists of start values/lower limits/upper limits for the fit parameters.
‘parallel\_points’: This should be something like the number of threads that can run in parallel/number of cores. The algorithm will first find a direction for a good descent and then check this number of points on the line. The best one will yield the new fit parameter set
‘number\_of\_cores’: number of jobs used in parallel. Best performance when set to the number of available cores on your computer.
‘strict’: usually this algorithm fails if the residuals are locally independent of one of the parameters. If you set ‘stict=False’ this parameter will be neglected locally.

If ‘control\_file’ is given, you can abort the optimization routine by writing “terminate 1” to the beginning of its first line.

If ‘plotfunction’ is given, it will be used to plot the current state of fitting (simulated data with currently best parameter set) after every iteration. It should take only one parameter: the array of fitparameters.

\end{fulllineitems}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{e}
\item {\sphinxstyleindexentry{Experiment}}\sphinxstyleindexpageref{modules-api/experiment:\detokenize{module-Experiment}}
\indexspace
\bigletter{f}
\item {\sphinxstyleindexentry{Fitters}}\sphinxstyleindexpageref{modules-api/fitters:\detokenize{module-Fitters}}
\indexspace
\bigletter{p}
\item {\sphinxstyleindexentry{Parameters}}\sphinxstyleindexpageref{modules-api/parameters:\detokenize{module-Parameters}}
\indexspace
\bigletter{s}
\item {\sphinxstyleindexentry{SampleRepresentation}}\sphinxstyleindexpageref{modules-api/samplerepresentation:\detokenize{module-SampleRepresentation}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}